# -*- coding: utf-8 -*-
"""SVM_and_random_Forest.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S7PMGY3CSdUVr-YHfv9LaFl9GY9it59W
"""

# # Data Preprocessing
# Importing the libraries
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Mounting Google Drive
from google.colab import drive
drive.mount('/content/drive')

# importing Dataset from Local drive
from google.colab import files
Uploaded=files.upload()

# Importing the dataset from Google Drive
dataset = pd.read_csv('Social_Network_Ads.csv')

print(dataset)

#Print Total number of Rows & columns in dataset
print(dataset.shape)

#Print Imformation about data
dataset.info()

# Extracting dependent and independent variables:
# Extracting independent variable:
X = dataset.iloc[:, 2:4].values
# Extracting dependent variable:
y = dataset.iloc[:, 4].values

print(X)

print(y)

# Splitting the dataset into the Training set and Test set
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state = 0)

print(X_train)

print(X_test)

print(y_test)

print(y_train)

# Feature Scaling
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

print(X_train)

print(X_test)

# Fitting SVM to the Training set
from sklearn.svm import SVC
classifier = SVC(kernel = 'linear', random_state = 0)
classifier.fit(X_train, y_train)

# Predicting the Test set results
y_pred = classifier.predict(X_test)

print(y_pred)

# Making the Confusion Matrix
from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_pred)
print('Confusion matrix: ')
print(cm)

# calculate Accuracy
# calculate Accuracy
#   0   1
# 0[66  2(FP type 1)]
#1 [8(FN Type 24) 23]
from sklearn.metrics import accuracy_score
print('Accuracy: %.2f' % (accuracy_score(y_test, y_pred)*100))

from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
# calculate precision
# Precision = TruePositives / (TruePositives + FalsePositives) 
# calculate Accuracy
#   0   1
# 0[59  7(FP type 1)]
#1 [ 11(FN Type 2) 23]= 23/30
precision = precision_score(y_test, y_pred, average='binary')
print('Precision: %.2f' % (precision))

# calculate recall
# Recall = TruePositives / (TruePositives + FalseNegatives)
# calculate Accuracy
#   0   1
# 0[59  7(FP type 1)]
#1 [ 11(FN Type 2) 23]= 23/23+11
recall = recall_score(y_test, y_pred, average='binary')
print('Recall: %.3f' % (recall))

# F-Measure = (2 * Precision * Recall) / (Precision + Recall)
# (2*0.829*0.906)/0.829+0.906
# calculate score
score = f1_score(y_test, y_pred, average='binary')
print('F-Measure: %.3f' % (score*100))

# Visualising the Training set results
from matplotlib.colors import ListedColormap
X_set, y_set = X_train, y_train
X1, X2 = np.meshgrid(np.arange(start = X_set[:, 0].min() - 1, stop = X_set[:, 0].max() + 1, step = 0.01),
                     np.arange(start = X_set[:, 1].min() - 1, stop = X_set[:, 1].max() + 1, step = 0.01))
plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),
             alpha = 0.75, cmap = ListedColormap(('red', 'green')))
plt.xlim(X1.min(), X1.max())
plt.ylim(X2.min(), X2.max())
for i, j in enumerate(np.unique(y_set)):
    plt.scatter(X_set[y_set == j, 0], X_set[y_set == j, 1],
                c = ListedColormap(('red', 'green'))(i), label = j)
plt.title('SVM (Training set)')
plt.xlabel('Age')
plt.ylabel('Estimated Salary')
plt.legend()
plt.show()

# Fitting SVM to the Training set
from sklearn.svm import SVC
classifier = SVC(kernel = 'rbf', random_state = 0)
classifier.fit(X_train, y_train)

# Predicting the Test set results
y_pred = classifier.predict(X_test)

# calculate Accuracy
from sklearn.metrics import accuracy_score
print('Accuracy: %.2f' % (accuracy_score(y_test, y_pred)*100))

# Visualising the Training set results
from matplotlib.colors import ListedColormap
X_set, y_set = X_train, y_train
X1, X2 = np.meshgrid(np.arange(start = X_set[:, 0].min() - 1, stop = X_set[:, 0].max() + 1, step = 0.01),
                     np.arange(start = X_set[:, 1].min() - 1, stop = X_set[:, 1].max() + 1, step = 0.01))
plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),
             alpha = 0.75, cmap = ListedColormap(('red', 'green')))
plt.xlim(X1.min(), X1.max())
plt.ylim(X2.min(), X2.max())
for i, j in enumerate(np.unique(y_set)):
    plt.scatter(X_set[y_set == j, 0], X_set[y_set == j, 1],
                c = ListedColormap(('red', 'green'))(i), label = j)
plt.title('SVM (Training set)')
plt.xlabel('Age')
plt.ylabel('Estimated Salary')
plt.legend()
plt.show()

# Fitting SVM to the Training set
from sklearn.svm import SVC
classifier = SVC(kernel = 'sigmoid', random_state = 0)
classifier.fit(X_train, y_train)

# Predicting the Test set results
y_pred = classifier.predict(X_test)

# calculate Accuracy
from sklearn.metrics import accuracy_score
print('Accuracy: %.2f' % (accuracy_score(y_test, y_pred)*100))

# Visualising the Training set results
from matplotlib.colors import ListedColormap
X_set, y_set = X_train, y_train
X1, X2 = np.meshgrid(np.arange(start = X_set[:, 0].min() - 1, stop = X_set[:, 0].max() + 1, step = 0.01),
                     np.arange(start = X_set[:, 1].min() - 1, stop = X_set[:, 1].max() + 1, step = 0.01))
plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),
             alpha = 0.75, cmap = ListedColormap(('red', 'green')))
plt.xlim(X1.min(), X1.max())
plt.ylim(X2.min(), X2.max())
for i, j in enumerate(np.unique(y_set)):
    plt.scatter(X_set[y_set == j, 0], X_set[y_set == j, 1],
                c = ListedColormap(('red', 'green'))(i), label = j)
plt.title('SVM (Training set)')
plt.xlabel('Age')
plt.ylabel('Estimated Salary')
plt.legend()
plt.show()

# Making the Confusion Matrix
from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_pred)
print('Confusion matrix: ')
print(cm)

# calculate Accuracy
from sklearn.metrics import accuracy_score
print('Accuracy: %.2f' % (accuracy_score(y_test, y_pred)*100))

from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
# calculate precision
# Precision = TruePositives / (TruePositives + FalsePositives)
precision = precision_score(y_test, y_pred, average='binary')
print('Precision: %.3f' % (precision*100))

# calculate recall
# Recall = TruePositives / (TruePositives + FalseNegatives)
recall = recall_score(y_test, y_pred, average='binary')
print('Recall: %.3f' % (recall*100))

# F-Measure = (2 * Precision * Recall) / (Precision + Recall)
# calculate score
score = f1_score(y_test, y_pred, average='binary')
print('F-Measure: %.3f' % (score*100))

age = 41 #@param {type:"number"}
estimated_Salary = 15000 #@param {type:"number"}
output=classifier.predict(sc.transform([[ age ,estimated_Salary ]]))
print("Purchased =", output)
if output==[1]:
  print( 'Custome will purchase Product')
else:
  print('Customer will not purchase computer')

import pickle 
  
# Save the trained model as a pickle string. 
saved_model = pickle.dumps(classifier) 
  
# Load the pickled model 
model = pickle.loads(saved_model) 
  
# Use the loaded pickled model to make predictions 
model.predict(X_test)

# save the model to disk
import joblib
filename = '/content/drive/My Drive/svm_model.sav'
joblib.dump(classifier, filename)
 
# some time later...
 
# load the model from disk
randomforest_model = joblib.load(filename)
result = randomforest_model.score(X_test, y_test)
print("Result is " , result)

import pickle 
print("[INFO] Saving model...")
# Save the trained model as a pickle string. 
saved_model=pickle.dump(classifier,open('/content/drive/My Drive/svmmodel.pkl', 'wb')) 
# Saving model to disk

# Load the pickled model 
model = pickle.load(open('/content/drive/My Drive/svmmodel.pkl', 'rb'))  
# Use the loaded pickled model to make predictions 
model.predict(X_test)

# Training the Random Forest Classification model on the Training set
from sklearn.ensemble import RandomForestClassifier
classifier = RandomForestClassifier(n_estimators = 200, criterion = 'entropy', random_state = 0)
classifier.fit(X_train, y_train)

# Predicting the Test set results
y_pred = classifier.predict(X_test)

# calculate Accuracy
from sklearn.metrics import accuracy_score
print('Accuracy: %.2f' % (accuracy_score(y_test, y_pred)*100))

# Visualising the Training set results
from matplotlib.colors import ListedColormap
X_set, y_set = X_train, y_train
X1, X2 = np.meshgrid(np.arange(start = X_set[:, 0].min() - 1, stop = X_set[:, 0].max() + 1, step = 0.01),
                     np.arange(start = X_set[:, 1].min() - 1, stop = X_set[:, 1].max() + 1, step = 0.01))
plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),
             alpha = 0.75, cmap = ListedColormap(('red', 'green')))
plt.xlim(X1.min(), X1.max())
plt.ylim(X2.min(), X2.max())
for i, j in enumerate(np.unique(y_set)):
    plt.scatter(X_set[y_set == j, 0], X_set[y_set == j, 1],
                c = ListedColormap(('red', 'green'))(i), label = j)
plt.title('Random Forest (Training set)')
plt.xlabel('Age')
plt.ylabel('Estimated Salary')
plt.legend()
plt.show()

# Making the Confusion Matrix
from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_pred)
print('Confusion matrix: ')
print(cm)

# calculate Accuracy
from sklearn.metrics import accuracy_score
print('Accuracy: %.2f' % (accuracy_score(y_test, y_pred)*100))

from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
# calculate precision
# Precision = TruePositives / (TruePositives + FalsePositives)
precision = precision_score(y_test, y_pred, average='binary')
print('Precision: %.3f' % (precision*100))

# calculate recall
# Recall = TruePositives / (TruePositives + FalseNegatives)
recall = recall_score(y_test, y_pred, average='binary')
print('Recall: %.3f' % (recall*100))

# F-Measure = (2 * Precision * Recall) / (Precision + Recall)
# calculate score
score = f1_score(y_test, y_pred, average='binary')
print('F-Measure: %.3f' % (score*100))

age =  25#@param {type:"number"}
estimated_Salary = 42000 #@param {type:"number"}
output=classifier.predict(sc.transform([[ age ,estimated_Salary ]]))
print("Perchased =", output)
if output==[1]:
  print( 'Custome will purchase Product')
else:
  print('Customer will not perchase computer')

import pickle 
print("[INFO] Saving model...")
# Save the trained model as a pickle string. 
saved_model=pickle.dump(classifier,open('/content/drive/My Drive/randomforest.pkl', 'wb')) 
# Saving model to disk

# Load the pickled model 
model = pickle.load(open('/content/drive/My Drive/randomforest.pkl', 'rb'))  
# Use the loaded pickled model to make predictions 
model.predict(X_test)

# Predicting the Test set results
y_pred = classifier.predict(X_test)

!pip install streamlit

# Mounting Google Drive
from google.colab import drive
drive.mount('/content/drive')

!pip install pyngrok

!ngrok authtoken 1rQ8XkYyUBK9R8KvW6wdVZD6HNI_44Zoypk4KP8df9VdpBAuQ

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st 
# from PIL import Image
# import pickle
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
# st.set_option('deprecation.showfileUploaderEncoding', False)
# # Load the pickled model
# model = pickle.load(open('/content/drive/My Drive/svmmodel.pkl', 'rb')) 
# model_randomforest = pickle.load(open('/content/drive/My Drive/randomforest.pkl', 'rb')) 
# dataset= pd.read_csv('/content/drive/My Drive/Social_Network_Ads.csv')
# X = dataset.iloc[:, [2, 3]].values
# from sklearn.preprocessing import StandardScaler
# sc = StandardScaler()
# X = sc.fit_transform(X)
# def predict_note_authentication(UserID, Gender,Age,EstimatedSalary):
#   output= model.predict(sc.transform([[Age,EstimatedSalary]]))
#   print("Purchased", output)
#   if output==[1]:
#     prediction="Item will be purchased"
#   else:
#     prediction="Item will not be purchased"
#   print(prediction)
#   return prediction
# def predict_random(UserID, Gender,Age,EstimatedSalary):
#   output= model_randomforest.predict(sc.transform([[Age,EstimatedSalary]]))
#   print("Purchased", output)
#   if output==[1]:
#     prediction="Item will be purchased"
#   else:
#     prediction="Item will not be purchased"
#   print(prediction)
#   return prediction
# def main():
#     
#     html_temp = """
#    <div class="" style="background-color:blue;" >
#    <div class="clearfix">           
#    <div class="col-md-12">
#    <center><p style="font-size:40px;color:white;margin-top:10px;">Poornima Institute of Engineering & Technology</p></center> 
#    <center><p style="font-size:30px;color:white;margin-top:10px;">Department of Computer Engineering</p></center> 
#    <center><p style="font-size:25px;color:white;margin-top:10px;"Machine Learning Lab Experiment</p></center> 
#    </div>
#    </div>
#    </div>
#    """
#     st.markdown(html_temp,unsafe_allow_html=True)
#     st.header("Item Purchase Prediction using SVM Algorithm")
#     UserID = st.text_input("UserID","Type Here")
#     Gender = st.selectbox(
#     "Gender",
#     ("Male", "Female", "Others")
#     )
#     
#     Age = st.number_input('Insert a Age',0,100)
#     #Age = st.text_input("Age","Type Here")
#     EstimatedSalary = st.number_input("Insert EstimatedSalary",1000,1000000000)
#     resul=""
#     if st.button("SVM Prediction"):
#       result=predict_note_authentication(UserID, Gender,Age,EstimatedSalary)
#       st.success('SVM Model has predicted {}'.format(result))
#     if st.button("Random Forest Prediction"):
#       result=predict_random(UserID, Gender,Age,EstimatedSalary)
#       st.success('Random forest Model  has predicted {}'.format(result))  
#     if st.button("About"):
#       st.header("Developed by Deepak Moud")
#       st.subheader("Head , Department of Computer Engineering")
#     html_temp = """
#     <div class="" style="background-color:orange;" >
#     <div class="clearfix">           
#     <div class="col-md-12">
#     <center><p style="font-size:20px;color:white;margin-top:10px;">Machine Learning Experiment 5: Support Vector Machine and Random Forest</p></center> 
#     </div>
#     </div>
#     </div>
#     """
#     st.markdown(html_temp,unsafe_allow_html=True)
# if __name__=='__main__':
#   main()

!nohup streamlit run  app.py &

from pyngrok import ngrok
url=ngrok.connect(port='8050')
url

!streamlit run --server.port 80 app.py

ngrok.kill()